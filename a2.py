# -*- coding: utf-8 -*-
"""A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z9DrUBThBrSCMqzoXGLQO3IfUJNSHVTC
"""

import numpy as np
import urllib.request as ur
import matplotlib.pyplot as plt

class KNNClassifier: #create the class
    def __init__(self, k): 
      self.k = k
        
    def __repr__(self): #returns the number of neighbors
      return str(self.k)
    
    def fit(self, X, y): #defines the fit function 
      self.x_train = X
      self.y_train = y

    def predict(self, X): #define the predict function
      self.x_predict = X
      prediction = [] #stores the predicted labels
      k = self.k
      for r in self.x_predict:  
          distance = np.sum((self.x_train - r)**2, axis=1)  #distance between each input row and each new row
          top_k = np.argsort(distance)[:k]
          count = np.bincount(self.y_train[top_k].astype('int32')) #finds frequency of each label in top_k and converts it to an integer then flattens the array
          prediction.append(np.argmax(count)) #add the label with the highest count to prediction list 
      return prediction
  


url = "http://www.pjreddie.com/media/files/mnist_train.csv" #load the url to maniuplate 
file = ur.urlopen(url)
data = np.loadtxt(file, delimiter = ',')

np.random.shuffle(data) #shuffle the data
#Create the validation and training data and labels

split_data_idx = int(data.shape[0]*0.8) #splitting the data 80%/20%

val_data = data[split_data_idx: , 1:]
train_data = data[:split_data_idx , 1:]
val_label = data[split_data_idx:, 0]
train_label = data[:split_data_idx, 0]

# create a for loop for the values of 1 to 25
acc = [] #list for the accuracy values 
knn = [KNNClassifier(k) for k in range(1 , 25)]
for i in range(len(knn)): #feed using the fit method 
    knn[i].fit(train_data, train_label)
    label_prediction = knn[i].predict(val_data)
    acc_k = np.sum(np.array(label_prediction) == val_label) / val_data.shape[0] #calculate the accuracy 
    acc.append(acc_k)
plt.plot(acc, knn)  
plt.show()